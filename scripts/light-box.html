<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ¿€å…‰åå°„å®éªŒå®¤</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }

        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }

        /* æ§åˆ¶é¢æ¿æ ·å¼ */
        .control-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 320px;
            max-height: 90vh;
            background: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid #444;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .control-group { margin-bottom: 16px; border-bottom: 1px solid #333; padding-bottom: 12px; }
        .control-group:last-child { border-bottom: none; }
        .label-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; font-size: 0.9rem; color: #ccc; }
        .value-display { font-family: monospace; color: #4ade80; font-size: 0.85rem; }

        input[type=range] {
            width: 100%;
            height: 6px;
            background: #444;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #ef4444; /* Red thumb for laser theme */
            border-radius: 50%;
            cursor: pointer;
            transition: background .2s;
        }
        input[type=range]::-webkit-slider-thumb:hover { background: #f87171; }

        .toggle-btn {
            width: 100%;
            padding: 8px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .toggle-btn:hover { background: #444; }
        .toggle-btn.active { background: #ef4444; border-color: #ef4444; }

        .title { font-size: 1.2rem; font-weight: bold; margin-bottom: 15px; color: #fff; border-bottom: 2px solid #ef4444; padding-bottom: 8px; display: inline-block;}
    </style>
</head>
<body>

    <!-- 3D å®¹å™¨ -->
    <div id="canvas-container"></div>

    <!-- UI æ§åˆ¶é¢æ¿ -->
    <div class="control-panel">
        <div class="title">ğŸ”¬ æ¿€å…‰å®éªŒå®¤æ§åˆ¶å°</div>

        <!-- ç›’å­è®¾ç½® -->
        <div class="control-group">
            <div class="font-bold text-white mb-2">ğŸ“¦ ç›’å­å°ºå¯¸ (ç±³)</div>
            <div class="label-row"><span>å®½åº¦ (X)</span> <span id="val-width" class="value-display">20</span></div>
            <input type="range" id="width" min="5" max="50" value="20">

            <div class="label-row mt-2"><span>é«˜åº¦ (Y)</span> <span id="val-height" class="value-display">10</span></div>
            <input type="range" id="height" min="5" max="30" value="10">

            <div class="label-row mt-2"><span>æ·±åº¦ (Z)</span> <span id="val-depth" class="value-display">20</span></div>
            <input type="range" id="depth" min="5" max="50" value="20">
        </div>

        <!-- æ¿€å…‰ç¬”è®¾ç½® -->
        <div class="control-group">
            <div class="font-bold text-white mb-2">ğŸ”¦ æ¿€å…‰ç¬”ä½ç½®ä¸è§’åº¦</div>

            <div class="label-row"><span>ä½ç½® X</span> <span id="val-posX" class="value-display">0</span></div>
            <input type="range" id="posX" min="-10" max="10" step="0.1" value="0">

            <div class="label-row mt-2"><span>ä½ç½® Y</span> <span id="val-posY" class="value-display">0</span></div>
            <input type="range" id="posY" min="-5" max="5" step="0.1" value="0">

            <div class="label-row mt-2"><span>ä½ç½® Z</span> <span id="val-posZ" class="value-display">0</span></div>
            <input type="range" id="posZ" min="-10" max="10" step="0.1" value="0">

            <div class="border-t border-gray-700 my-3"></div>

            <div class="label-row"><span>æ°´å¹³è§’åº¦ (Yaw)</span> <span id="val-yaw" class="value-display">45Â°</span></div>
            <input type="range" id="yaw" min="0" max="360" value="45">

            <div class="label-row mt-2"><span>å‚ç›´è§’åº¦ (Pitch)</span> <span id="val-pitch" class="value-display">0Â°</span></div>
            <input type="range" id="pitch" min="-89" max="89" value="0">
        </div>

        <!-- å…‰çº¿ç‰©ç†è®¾ç½® -->
        <div class="control-group">
            <div class="font-bold text-white mb-2">âš¡ å…‰çº¿ç‰©ç†å±æ€§</div>

            <div class="label-row"><span>å…‰çº¿ä¼ æ’­é€Ÿåº¦</span> <span id="val-speed" class="value-display">1.0x</span></div>
            <input type="range" id="speed" min="0.1" max="5.0" step="0.1" value="1.0">

            <div class="label-row mt-2"><span>å…‰å¼ºè¡°å‡ç³»æ•°</span> <span id="val-decay" class="value-display">0.05</span></div>
            <input type="range" id="decay" min="0" max="0.2" step="0.005" value="0.05">
            <p class="text-xs text-gray-500 mt-1">å€¼è¶Šå¤§ï¼Œå…‰çº¿æ¶ˆå¤±è¶Šå¿«</p>

            <div class="label-row mt-2"><span>æœ€å¤§åå°„æ¬¡æ•°</span> <span id="val-maxBounces" class="value-display">100</span></div>
            <input type="range" id="maxBounces" min="10" max="5000" step="10" value="100">
            <p class="text-xs text-gray-500 mt-1">å¢åŠ æ­¤å€¼å¯å…è®¸æ›´å¤šæ¬¡åå¼¹</p>
        </div>

        <button id="reset-cam" class="toggle-btn">é‡ç½®ç›¸æœºè§†è§’</button>
        <div class="mt-2 text-xs text-gray-400 text-center">
            å·¦é”®æ—‹è½¬ â€¢ å³é”®å¹³ç§» â€¢ æ»šè½®ç¼©æ”¾
        </div>
    </div>

    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, controls;
        let boxMesh, boxHelper;
        let laserSourceMesh; // æ¿€å…‰ç¬”æ¨¡å‹
        let laserRayMesh; // æ¿€å…‰å…‰æŸ
        let laserPath = []; // å­˜å‚¨è®¡ç®—å‡ºçš„åå°„è·¯å¾„ç‚¹

        // é…ç½®å‚æ•°
        const params = {
            width: 20,
            height: 10,
            depth: 20,
            posX: 0,
            posY: 0,
            posZ: 0,
            yaw: 45, // åº¦
            pitch: 0, // åº¦
            speed: 1.0,
            decay: 0.05,
            maxBounces: 100 // æœ€å¤§åå°„æ¬¡æ•°
        };

        // åŠ¨ç”»çŠ¶æ€
        let currentDrawDistance = 0; // å½“å‰ç”»äº†å¤šé•¿çš„çº¿
        let totalPathDistance = 0;   // å®Œæ•´è·¯å¾„çš„æ€»é•¿åº¦

        // --- åˆå§‹åŒ– ---
        function init() {
            // 1. åœºæ™¯è®¾ç½®
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            // 2. ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, 15, 25);

            // 3. æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // 5. ç¯å…‰ (ä¸ºäº†çœ‹æ¸…æ¿€å…‰ç¬”)
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            // 6. åˆ›å»ºå¯¹è±¡
            createBox();
            createLaserSource();
            createLaserRay(); // åˆå§‹åŒ–ç©ºçš„æ¿€å…‰çº¿

            // 7. äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize);
            document.getElementById('reset-cam').addEventListener('click', () => {
                camera.position.set(25, 15, 25);
                controls.target.set(0,0,0);
            });

            // ç»‘å®šæ‰€æœ‰ Range Input
            const inputs = document.querySelectorAll('input[type=range]');
            inputs.forEach(input => {
                input.addEventListener('input', updateParams);
            });

            // åˆå§‹è®¡ç®—
            recalculatePath();
            animate();
        }

        // --- åˆ›å»º/æ›´æ–° 3D å¯¹è±¡ ---

        function createBox() {
            // ç§»é™¤æ—§çš„
            if (boxMesh) scene.remove(boxMesh);
            if (boxHelper) scene.remove(boxHelper);

            // åˆ›å»ºç›’å­å‡ ä½•ä½“
            const geometry = new THREE.BoxGeometry(params.width, params.height, params.depth);

            // æè´¨ï¼šBackSide æ¸²æŸ“å†…éƒ¨ï¼Œçœ‹èµ·æ¥åƒæ·±è‰²é•œé¢
            const material = new THREE.MeshPhysicalMaterial({
                color: 0x222222,
                metalness: 0.8,
                roughness: 0.2,
                side: THREE.BackSide, // å…³é”®ï¼šæ¸²æŸ“å†…éƒ¨
                transparent: true,
                opacity: 0.8
            });

            boxMesh = new THREE.Mesh(geometry, material);
            scene.add(boxMesh);

            // æ·»åŠ ç½‘æ ¼è¾…åŠ©çº¿ï¼Œè®©ç›’å­çœ‹èµ·æ¥æ›´æœ‰ç§‘æŠ€æ„Ÿ
            boxHelper = new THREE.BoxHelper(boxMesh, 0x555555);
            scene.add(boxHelper);
        }

        function createLaserSource() {
            // æ¿€å…‰ç¬”æ¨¡å‹ï¼šä¸€ä¸ªåœ†æŸ±ä½“ + ä¸€ä¸ªé”¥ä½“
            const group = new THREE.Group();

            const bodyGeo = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 16);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = -Math.PI / 2; // æŒ‡å‘ Z è½´

            const tipGeo = new THREE.ConeGeometry(0.25, 0.5, 16);
            const tipMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.5 });
            const tip = new THREE.Mesh(tipGeo, tipMat);
            tip.rotation.x = -Math.PI / 2;
            tip.position.z = 1.0;

            group.add(body);
            group.add(tip);

            laserSourceMesh = group;
            scene.add(laserSourceMesh);
        }

        function createLaserRay() {
            // ä½¿ç”¨ BufferGeometry åˆ›å»ºçº¿
            // å¢åŠ åˆ° 3000 ä¸ªé¡¶ç‚¹ä»¥æ”¯æŒé«˜åå°„æ¬¡æ•°
            const maxPoints = 3000;
            const geometry = new THREE.BufferGeometry();

            const positions = new Float32Array(maxPoints * 3);

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            // æ¿€å…‰æè´¨ï¼šçº¢è‰²ï¼ŒAdditiveBlending ä¼šè®©é‡å éƒ¨åˆ†æ›´äº®ï¼Œçœ‹èµ·æ¥åƒå…‰
            const material = new THREE.LineBasicMaterial({
                color: 0xff0000,
                linewidth: 2,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            laserRayMesh = new THREE.Line(geometry, material);
            // ç¡®ä¿ä¸è¢«è§†é”¥å‰”é™¤
            laserRayMesh.frustumCulled = false;
            scene.add(laserRayMesh);
        }

        // --- æ ¸å¿ƒç‰©ç†é€»è¾‘ï¼šå…‰çº¿è¿½è¸ª ---

        function recalculatePath() {
            laserPath = []; // æ¸…ç©ºè·¯å¾„
            totalPathDistance = 0;
            currentDrawDistance = 0; // é‡ç½®åŠ¨ç”»

            // 1. èµ·ç‚¹
            let origin = new THREE.Vector3(params.posX, params.posY, params.posZ);

            // 2. åˆå§‹æ–¹å‘ (åŸºäº Yaw å’Œ Pitch è®¡ç®—)
            const euler = new THREE.Euler(
                THREE.MathUtils.degToRad(-params.pitch),
                THREE.MathUtils.degToRad(-params.yaw),
                0,
                'YXZ'
            );
            let direction = new THREE.Vector3(0, 0, 1).applyEuler(euler).normalize();

            // æ›´æ–°æ¿€å…‰ç¬”æ¨¡å‹çš„ä½ç½®å’Œæœå‘
            laserSourceMesh.position.copy(origin);
            laserSourceMesh.setRotationFromEuler(euler);

            // æ·»åŠ èµ·ç‚¹
            laserPath.push({ point: origin.clone(), distance: 0 });

            // 3. å‡†å¤‡ Raycaster
            const raycaster = new THREE.Raycaster();

            // å®šä¹‰ç›’å­çš„è¾¹ç•Œ
            const halfW = params.width / 2;
            const halfH = params.height / 2;
            const halfD = params.depth / 2;

            let currentPos = origin.clone();
            let currentDir = direction.clone();
            let totalDist = 0;

            // 4. å¾ªç¯åå°„ï¼Œä½¿ç”¨ maxBounces å‚æ•°
            for (let i = 0; i < params.maxBounces; i++) {
                raycaster.set(currentPos, currentDir);

                // æˆ‘ä»¬æ£€æµ‹ä¸ç›’å­å†…éƒ¨çš„ç¢°æ’ (BackSide)
                const intersects = raycaster.intersectObject(boxMesh);

                if (intersects.length > 0) {
                    let hit = null;
                    // é˜²æ­¢è‡ªæˆ‘ç›¸äº¤
                    for(let k=0; k<intersects.length; k++) {
                        if(intersects[k].distance > 0.001) {
                            hit = intersects[k];
                            break;
                        }
                    }

                    if (hit) {
                        const hitPoint = hit.point;
                        const dist = hit.distance;

                        totalDist += dist;

                        // è®°å½•è·¯å¾„ç‚¹
                        laserPath.push({
                            point: hitPoint.clone(),
                            distance: totalDist
                        });

                        // å¼ºåº¦æ£€æŸ¥
                        const intensity = Math.exp(-params.decay * totalDist);
                        // å¦‚æœè¡°å‡éå¸¸å¤§ä¸”å¼ºåº¦å·²ç»å¾ˆå¼±ï¼Œåˆ™åœæ­¢ï¼Œé™¤é decay æ˜¯ 0
                        if (params.decay > 0 && intensity < 0.01) break;

                        // æ ¹æ®å‡»ä¸­ç‚¹åæ ‡åˆ¤æ–­æ³•çº¿ (Boxæ³•çº¿ç®€åŒ–å¤„ç†)
                        let normal = new THREE.Vector3();
                        const epsilon = 0.01;

                        if (Math.abs(hitPoint.x - halfW) < epsilon) normal.set(-1, 0, 0);
                        else if (Math.abs(hitPoint.x + halfW) < epsilon) normal.set(1, 0, 0);
                        else if (Math.abs(hitPoint.y - halfH) < epsilon) normal.set(0, -1, 0);
                        else if (Math.abs(hitPoint.y + halfH) < epsilon) normal.set(0, 1, 0);
                        else if (Math.abs(hitPoint.z - halfD) < epsilon) normal.set(0, 0, -1);
                        else if (Math.abs(hitPoint.z + halfD) < epsilon) normal.set(0, 0, 1);
                        else {
                             normal.copy(hit.face.normal).negate();
                        }

                        // è®¡ç®—æ–°çš„åå°„æ–¹å‘
                        currentDir.reflect(normal).normalize();
                        currentPos = hitPoint.clone();

                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }
            totalPathDistance = totalDist;
        }

        // --- æ¸²æŸ“å¾ªç¯ ---

        function updateLaserVisuals() {
            // åŠ¨ç”»é€»è¾‘
            const speed = params.speed * 0.5;
            currentDrawDistance += speed;

            if (currentDrawDistance > totalPathDistance) {
                currentDrawDistance = totalPathDistance;
            }

            const positions = laserRayMesh.geometry.attributes.position.array;
            let posIndex = 0;

            if (laserPath.length > 0) {
                positions[posIndex++] = laserPath[0].point.x;
                positions[posIndex++] = laserPath[0].point.y;
                positions[posIndex++] = laserPath[0].point.z;
            }

            let distCovered = 0;

            for (let i = 0; i < laserPath.length - 1; i++) {
                const p1 = laserPath[i].point;
                const p2 = laserPath[i+1].point;

                const segmentLength = p1.distanceTo(p2);

                if (distCovered + segmentLength > currentDrawDistance) {
                    // æ’å€¼
                    const remaining = currentDrawDistance - distCovered;
                    const alpha = remaining / segmentLength;

                    const pEnd = new THREE.Vector3().lerpVectors(p1, p2, alpha);

                    positions[posIndex++] = pEnd.x;
                    positions[posIndex++] = pEnd.y;
                    positions[posIndex++] = pEnd.z;

                    laserRayMesh.geometry.setDrawRange(0, i + 2);
                    break;
                } else {
                    positions[posIndex++] = p2.x;
                    positions[posIndex++] = p2.y;
                    positions[posIndex++] = p2.z;
                    distCovered += segmentLength;

                    if (i === laserPath.length - 2) {
                        laserRayMesh.geometry.setDrawRange(0, i + 2);
                    }
                }
            }
            laserRayMesh.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateLaserVisuals();
            renderer.render(scene, camera);
        }

        // --- UI äº¤äº’é€»è¾‘ ---

        function updateParams(e) {
            const id = e.target.id;
            const val = parseFloat(e.target.value);

            params[id] = val;

            // æ›´æ–°æ˜¾ç¤ºæ–‡æœ¬
            const display = document.getElementById(`val-${id}`);
            if (display) {
                if (id === 'yaw' || id === 'pitch') display.innerText = val + 'Â°';
                else if (id === 'speed') display.innerText = val.toFixed(1) + 'x';
                else display.innerText = val;
            }

            // é™åˆ¶æ¿€å…‰ä½ç½®åœ¨ç›’å­å†…éƒ¨
            if (id.startsWith('width') || id.startsWith('height') || id.startsWith('depth')) {
                // æ›´æ–°ç›’å­å¤§å°
                createBox();

                // åŠ¨æ€æ›´æ–° Slider çš„ min/max ä»¥é˜²æ­¢æ¿€å…‰è·‘åˆ°å¤–é¢
                const pX = document.getElementById('posX');
                const pY = document.getElementById('posY');
                const pZ = document.getElementById('posZ');

                if(pX) { pX.min = -params.width/2 + 0.5; pX.max = params.width/2 - 0.5; }
                if(pY) { pY.min = -params.height/2 + 0.5; pY.max = params.height/2 - 0.5; }
                if(pZ) { pZ.min = -params.depth/2 + 0.5; pZ.max = params.depth/2 - 0.5; }
            }

            // é‡æ–°è®¡ç®—è·¯å¾„
            recalculatePath();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // å¯åŠ¨
        init();

    </script>
</body>
</html>